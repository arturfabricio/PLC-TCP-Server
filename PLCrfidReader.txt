CASE state OF
	0: //init.
	IO.xQA1_RIGHT := TRUE;
	IO.xMB20 := FALSE;
	RFID.ClearError(); //Takes a few cycles for the RFID to be ready.
	state := 1;
	
	1: //Wait for RFID to clear.
	IF RFID.xReady THEN //Boolean flag, raises it whenever the RFID is ready again.
		RFID.Connect(); 
		state := 2;
	END_IF
	
	2: //Wait for RFID to connect.
	IF RFID.xReady AND RFID.xConnected THEN //Boolean flag, raises it whenever the RFID is ready again.
		state := 3;
	END_IF
	
	3: //carrier wait
	IF IO.xBG21 = TRUE THEN
		IO.xMB20 := TRUE;
		state := 4;
	END_IF
	 
	4: //Reading the RFID tag.
	RFID.ReadTag(uiStartAddress := 0, uiDataLength := SIZEOF(RFIDdata), ADR(RFIDdata)); //Telling the RFID where to start, the amount of data we want to write from the tag, and an address to the data to write.
	state := 5;
	
	5: //wait for RFID read:
	IF RFID.xReady THEN //Boolean flag, raises it whenever the RFID is ready again.
		IF RFIDdata.uiCarrierID <= 8 THEN
			state := 10;
		ELSE
			state := 20;
		END_IF
	END_IF
	
	//State 10 and 20 are parallel flows, bothe converging in state 30.
	
	10: //Release Pallet 1 - 8
	IO.xMB20 := TRUE;
	state := 30;
	
	20: //Release pallet 9 - 16.
	timer(IN:=TRUE, pt:=T#2S);
	state := 21;
	
	21: //Wait for timer.
	IF timer.Q THEN
		IO.xMB20 := TRUE;
		state := 30;
	END_IF
	
	30: //Wait for carrier to pass:
	IF IO.xBG21 = FALSE THEN
		IO.xMB20 := FALSE;
		state := 3;
	END_IF
END_CASE
RFID();
timer();
